### 协程

- 协程是一种轻量级线程，可以在用户态实现上下文的切换，不像线程那样，上下文切换由OS操控，要涉及用户态和内核态的切换。而，协程的切换完全是在用户态，切换速度快，开销小。
- 所有的协程都处在一个线程中，约定：在同一个时刻，该线程只能有一个协程处于running状态，其他线程都会阻塞。正因为如此，协程的同步不像线程那样需要加锁。
- 协程在应用层实现上下文切换，过程：
  - ① 将当前协程的上下文保存在寄存器中
  - ② 切走当前协程，执行其他的协程
  - ③ 执行完其他协程后，再切回之前协程的上下文，继续执行

### libco协程实现原理

- 全局唯一的协程环境
  - pCallSTack 协程调用栈（libco的协程是非对称协程）
    - 有点类似于函数调用栈，假如在协程A中开启了协程B，协程B中开启了协程C，那么pCallStack=[A,B,C]，栈顶元素始终是当前正在running的协程
    - co_create
      - 创建协程，为协程绑定上下文（堆栈、协程函数）
    - co_resume
      - 将co保存到pCallStack中
      - co_swap(curr, co) 切换到目标协程co，运行co绑定的协程函数
  - epoll管理者: 对(IO事件/超时事件)进行监管
    - IO事件
      - 
    - 超时事件
      - 时间堆

- poll  （采用hook机制，对原函数poll进行改造）

  ```c++
  poll(NULL, 0, 1000);    // 超时事件
  poll( &pf,1,timeout );  // 读写事件
  ```

  - 将(IO事件/超时事件)托管给epoll中监管，如何实现托管的呢？
    - IO事件
      - co_epoll_ctl: 将其添加到epoll中，监控其上的IO事件的到来
      - co_yield_env: 从当前事件的协程，切换到co_event_loop协程
      - 当读写事件触发后，co_event_loop会将该事件移到就绪链表中
      - 之后，处理就绪链表中就绪的事件，即：调用注册的事件协程的回调函数（切回该事件的协程），切回来后，继续读写操作
    - 超时事件
      - 超时事件，添加到小根堆中，由epoll监管
      - co_yield_env: 从当前事件的协程，切换到co_event_loop协程
      - 当超时事件触发后，co_event_loop会将该事件移到就绪链表中
      - 之后，处理就绪链表中就绪的事件，即：调用注册的事件协程的回调函数（切回该事件的协程），切回来后，继续执行该协程下面的操作



----

- read/write/connect/…

  - 都采用了HOOK机制
  - 在函数内部，都调用了上面讲到的poll

  以read函数调用举例

  - 传统的read函数，要进行2步：
    - 阻塞等待数据的到来
    - 数据到来后，阻塞的读取数据
  - 本文中的read，采用epoll+协程切换，将同步阻塞调用转变为同步异步调用
    - 当调用read函数后，不会阻塞等待数据的到来
      - （1）而是将该read事件的协程保存起来，将read事件添加到epoll中管理
      - （2）co_yield_env：（协程切换）read事件所处的协程  --> co_event_loop协程
      - （3）当epoll监测到有read事件触发后，将调用该read事件注册的回调函数（会重新切回read协程，再执行第二步，见下）
    - 数据到来后，还是阻塞的读取数据

----

经过上面的read介绍，可以发现：

- 对于所有的（IO事件/超时事件），都应该在外部包裹一个协程，代码的书写就显而易见了。

举例：下面代码书写方式肯定不对，此处只是为了描述原理

```c++
static void *readwrite_routine( void *arg ){
    while (1) {
        read(fd, xx, xx);  // read内部调用了poll
        				   //     将read事件托管给epoll监听，切回到主协程
        				   // 当读事件到来后，会切回来，执行读取数据的操作，此时read函数才真正的执行完毕
    }
}

int main(){
    stCoRoutine_t* co;
	
    co_create(&co, NULL,readwrite_routine, xx);  // 1. 首先要为read事件创建一个协程
    co_resume( co );   // 切换到读协程中去
    
    co_eventloop( co_get_epoll_ct(),0,0 );  // 监听事件的到来
    						// 当读事件到来后，会再次切回read函数的位置
}
```

